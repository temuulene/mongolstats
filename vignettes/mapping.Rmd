---
title: "Mapping with mongolstats"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Mapping with mongolstats}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
eval_site <- identical(Sys.getenv("PKGDOWN_EVAL"), "true")
knitr::opts_chunk$set(eval = eval_site, message = FALSE, warning = FALSE)
```

```{r}
library(mongolstats)
library(dplyr)
library(sf)
```

This vignette shows how to join data to ADM1 boundaries by name.

```{r}
adm1 <- mn_boundaries("ADM1") %>% mn_boundaries_normalize()
head(adm1$name_std)
```

Suppose we fetched a table that reports values by aimag:

```{r}
# Replace with a table that has region breakdowns
tbl <- "DT_NSO_0500_007V1"  # GDP by region, aimag and capital

periods <- nso_table_periods(tbl)
dat <- if (length(periods)) nso_data(tbl, period = tail(periods, 1)) else tibble::tibble()

# Assume English names are in one of the label columns (e.g., scr_eng1)
# Create a synthetic name column for demo if needed
nm_col <- intersect(names(dat), c("scr_eng", "scr_eng1", "scr_eng2"))[1]
if (is.na(nm_col) || length(nm_col) == 0) nm_col <- intersect(names(dat), names(dat))[1]
if (!is.null(nm_col) && !is.na(nm_col) && nm_col %in% names(dat)) {
  dat$name <- dat[[nm_col]]
}

joined <- tryCatch(mn_join_by_name(dat, name_col = "name", level = "ADM1"), error = function(e) adm1)
plot(sf::st_geometry(joined))
```

Note: Name-based joins are heuristic. For rigorous joins, prefer stable codes
once a consistent NSO geographic classification is identified.
